# createForm

This method creates a new "form instance" representing the form in your application.

## Options

```js
type FormProps<TForm extends Record<string, unknown>> = {
    initial: TForm;
    validators?: Validators<TForm>;
    asyncValidators?: AsyncValidators<TForm>;
    onSubmitForm?: (form: TForm) => void;
    config?: FormConfig;
};
```

`initial`

Required property representing the initial object model for your form.

`validators`

Object representing client validator for the matching form field.

`asyncValidators`

Object representing server/async validator for the matching form field.

`onSubmitForm`

Use this function to protect your "form submitting flow". This method gets called
only if all form fields pass validation.

`config`

Allows overriding global form config for the particular instance of form.

## Returns

```js
export type FormResult<TForm> = {
  form: TForm;
  validations: ValidationResults<TForm>;
  update: <Key extends keyof TForm>(key: Key, value: TForm[Key]) => void;
  runValidation: <Key extends keyof TForm>(key: Key) => void;
  submit: () => void;
  isValid: boolean;
  isValidating: boolean;
};
```

`form`

Latest form state.

`validations`

Each form field will have its own validation object attached to it.
The object will contain validation status information that can be used in your presentation layer.

`update`

Call this method to update the form value for specific key.

`runValidation`

Manually run validation for given field. All validation results are cached and not repeated until the
value changes.

`submit`

Use this method to "protect" your server from un-validated or invalid input.
Calling this method starts both client and server side validations for every form field, and
calls "onSubmitForm" if all fields pass validation.

`isValid`

True if there are no pending or ongoing validations.

`isValidating`

True if there are ongoing validations.
